--------------------
--  Join
--------------------

--  employees와 departments 테이블 확인
DESC employees;
DESC departments;

select * from employees;    --  107
select * from departments;     --   27

select first_name, department_name
from employees, departments;
-- 두 테이블의 조합 가능한 모든 행이 출력됨
--  카티젼 프로덕트, Cross Join
--  일반적으로 이런 결과를 원하지는 않을 것

--  두 테이블의 연결 조건을 Where에 부여 -> simple Join

select *
from employees, departments
where employees.department_id = departments.department_id; --   106

--  필드의 모호성을 해소하기 위해 테이블명 혹은 alias를 부여한다
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp, departments dept
where emp.department_id = dept.department_id; --    106

--  INNER JOIN
select emp.first_name,
    dept.department_name
from employees emp JOIN departments dept
                    USING (department_id);
                    
select first_name,
    department_name
from employees emp JOIN departments dept
                        on emp.department_id = dept.department_id;
                        --  ON은 JOIN의 조건을 명시할 때 사용
                        --  WHERE는 SELECT의 조건을 명시할 떄 사용
                        
select first_name, department_name
from employees NATURAL JOIN departments;    -- NATURAL JOIN
--  같은 이름을 가진 컬럼을 기준으로 JOIN

--  Theta JOIN
--  특정 조건을 기준으로 JOIN을 한다
--  조건이 = 이 아닌 경우
--  Non-Equi JOIN 이라고도 한다
select * from jobs where job_id = 'FI_MGR';

select first_name, salary from employees emp, jobs j
where j.job_id = 'FI_MGR' AND salary BETWEEN j.min_salary AND j.max_salary;

-------------------
--  Outer JOIN
-------------------
--  조건이 만족하는 짝이 없는 레코드도 null을 포함하여 결과를 출력
--  모든 레코드를 출력할 테이블이 어느 위치에 있는가에 따라서 LEFT, RIGHT, FULL
--  ORACLE SQL의 경우 NULL이 출력될 수 있는 쪽 조건에 (+)를 붙인다

--INNER JOIN
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp, departments dept
where emp.department_id = dept.department_id;   --  106

--  전체 사원 수
select count(*) from employees; --  107 한 명은 어디갔을까

--  부서 id가 null인 직원
select first_name, department_id
from employees
where department_id is NULL;

--  LEFT OUTER JOIN : 짝이 없어도 왼쪽의 테이블 전체를 출력에 참여 시킴
--  ORACLE SQL
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp, departments dept
where emp.department_id = dept.department_id(+);    --  107

--  ANSI SQL
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp LEFT OUTER JOIN departments dept 
                        ON emp.department_id = dept.department_id;
                        
--  RIGHT OUTER JOIN
--  오른쪽 테이블의 모든 레코드를 출력에 참여 -> 왼쪽 테이블에 매칭되는 짝이 없는 경우
--  왼쪽 테이블 컬럼이 NULL 표기된다
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp, departments dept
where emp.department_id(+) = dept.department_id; -- 122

--  ANSI SQL
select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp RIGHT OUTER JOIN departments dept
                    ON emp.department_id = dept.department_id; --   122

--  FULL OUTER JOIN
--  양쪽 테이블 모두 짝이 없어도 출력에 참여

--  ERROR
--select first_name,
--    emp.department_id,
--    dept.department_id,
--    department_name
--from employees emp, department dept
--where emp.department_id (+) = dept.department_id (+);
--  ORACLE SQL에서는 LEFT / RIGHT OUTER JOIN만 실행 가능하다

--  ANSI SQL
Select first_name,
    emp.department_id,
    dept.department_id,
    department_name
from employees emp FULL OUTER JOIN departments dept
                        ON emp.department_id = dept.department_id;
                        
--  JOIN 연습
--  부서 ID, 부서명, 속한 도시명, 국가명을 출력!_!
select department_id,
    department_name,
    city,
    country_name
from departments dept, locations loc JOIN countries co
                    ON  loc.country_id = co.country_id
where dept.location_id = loc.location_id
order by dept.department_id asc;

--  ON

select department_id,
    department_name,
    city,
    country_name
from departments dept, locations loc, countries ct
where dept.location_id = loc.location_id AND
    loc.country_id = ct.country_id
order by department_id asc;

-----------
--  SELF JOIN
------------
--  자기 자신과 JOIN
--  한개 데이블을 두 번 이상 사용해야하므로 반드시 Alias 사용
select *  from employees;   --  107

--  사원의 아이디, 사원 이름, 매니저 아이디, 매니저 이름
select emp.employee_id,
    emp.first_name,
    emp.manager_id,
    man.first_name
from employees emp JOIN employees man
                    ON emp.manager_id = man.employee_id;    --  106
                    
-- OR

select emp.employee_id,
    emp.first_name,
    emp.manager_id,
    man.first_name
from employees emp, employees man
where emp.manager_id = man.employee_id; --  106

select * from employees
where manager_id is null;

--  매니저가 없는 사람도 출력
select emp.employee_id,
    emp.first_name,
    emp.manager_id,
    man.first_name
from employees emp, employees man
where emp.manager_id = man.employee_id (+); --  107